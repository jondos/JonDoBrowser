diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -193,6 +193,7 @@
 #include "nsIChannelPolicy.h"
 #include "nsIContentSecurityPolicy.h"
 #include "nsSandboxFlags.h"
+#include "mozIThirdPartyUtil.h"
 
 #include "nsXULAppAPI.h"
 
@@ -2691,14 +2692,29 @@ nsDocShell::GetSessionStorageForPrincipal(nsIPrincipal* aPrincipal,
         return NS_ERROR_UNEXPECTED;
     }
 
+    nsCOMPtr<mozIThirdPartyUtil> thirdPartyUtil =
+                            do_GetService(THIRDPARTYUTIL_CONTRACTID);
+    if (!thirdPartyUtil)
+      return NS_ERROR_FAILURE;
+
+    nsCOMPtr<nsIDocument> doc(do_GetInterface(GetAsSupports(this)));
+    nsCOMPtr<nsIURI> firstPartyURI;
+    nsresult rv = thirdPartyUtil->GetFirstPartyURI(nullptr, doc,
+                                           getter_AddRefs(firstPartyURI));
+    NS_ENSURE_SUCCESS(rv, rv);
+
     if (aCreate) {
-        return manager->CreateStorage(aPrincipal, aDocumentURI,
+        return manager->CreateStorageForFirstParty(firstPartyURI,
+                                      aPrincipal, aDocumentURI,
                                       mInPrivateBrowsing, aStorage);
     }
 
-    return manager->GetStorage(aPrincipal, mInPrivateBrowsing, aStorage);
+    return manager->GetStorageForFirstParty(firstPartyURI, aPrincipal,
+                                            mInPrivateBrowsing, aStorage);
 }
 
+// Bacause it is not called from anywhere, nsDocShell::AddSessionStorage()
+// does not need to be modified to isolate DOM Storage to the first party URI.
 nsresult
 nsDocShell::AddSessionStorage(nsIPrincipal* aPrincipal,
                               nsIDOMStorage* aStorage)

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -2596,6 +2596,11 @@ nsGlobalWindow::PreloadLocalStorage()
   }
 
   nsresult rv;
+  nsCOMPtr<nsIURI> firstPartyURI;
+  rv = GetFirstPartyURI(getter_AddRefs(firstPartyURI));
+  if (NS_FAILED(rv)) {
+    return;
+  }
 
   nsCOMPtr<nsIDOMStorageManager> storageManager =
     do_GetService("@mozilla.org/dom/localStorage-manager;1", &rv);
@@ -2603,7 +2608,7 @@ nsGlobalWindow::PreloadLocalStorage()
     return;
   }
 
-  storageManager->PrecacheStorage(principal);
+  storageManager->PrecacheStorageForFirstParty(firstPartyURI, principal);
 }
 
 void
@@ -6650,6 +6655,19 @@ nsGlobalWindow::CallerInnerWindow()
   return static_cast<nsGlobalWindow*>(win.get());
 }
 
+nsresult
+nsGlobalWindow::GetFirstPartyURI(nsIURI** aFirstPartyURI)
+{
+  nsCOMPtr<mozIThirdPartyUtil> thirdPartyUtil =
+                               do_GetService(THIRDPARTYUTIL_CONTRACTID);
+  if (!thirdPartyUtil)
+    return NS_ERROR_FAILURE;
+
+  nsCOMPtr<nsIDocument> doc = do_QueryInterface(mDoc);
+  return thirdPartyUtil->GetFirstPartyURI(NULL, doc, aFirstPartyURI);
+}
+
+
 /**
  * Class used to represent events generated by calls to Window.postMessage,
  * which asynchronously creates and dispatches events.
@@ -8956,7 +8974,11 @@ nsGlobalWindow::GetSessionStorage(nsIDOMStorage ** aSessionStorage)
 
     nsCOMPtr<nsILoadContext> loadContext = do_QueryInterface(docShell);
 
-    rv = storageManager->CreateStorage(principal,
+    nsCOMPtr<nsIURI> firstPartyURI;
+    rv = GetFirstPartyURI(getter_AddRefs(firstPartyURI));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = storageManager->CreateStorageForFirstParty(firstPartyURI, principal,
                                        documentURI,
                                        loadContext && loadContext->UsePrivateBrowsing(),
                                        getter_AddRefs(mSessionStorage));
@@ -9024,10 +9046,14 @@ nsGlobalWindow::GetLocalStorage(nsIDOMStorage ** aLocalStorage)
       mDoc->GetDocumentURI(documentURI);
     }
 
+    nsCOMPtr<nsIURI> firstPartyURI;
+    rv = GetFirstPartyURI(getter_AddRefs(firstPartyURI));
+    NS_ENSURE_SUCCESS(rv, rv);
+
     nsIDocShell* docShell = GetDocShell();
     nsCOMPtr<nsILoadContext> loadContext = do_QueryInterface(docShell);
 
-    rv = storageManager->CreateStorage(principal,
+    rv = storageManager->CreateStorageForFirstParty(firstPartyURI, principal,
                                        documentURI,
                                        loadContext && loadContext->UsePrivateBrowsing(),
                                        getter_AddRefs(mLocalStorage));
@@ -9644,7 +9670,13 @@ nsGlobalWindow::Observe(nsISupports* aSubject, const char* aTopic,
 
       nsCOMPtr<nsIDOMStorageManager> storageManager = do_QueryInterface(GetDocShell());
       if (storageManager) {
-        rv = storageManager->CheckStorage(principal, changingStorage, &check);
+        nsresult rv;
+        nsCOMPtr<nsIURI> firstPartyURI;
+        rv = GetFirstPartyURI(getter_AddRefs(firstPartyURI));
+        NS_ENSURE_SUCCESS(rv, rv);
+
+        rv = storageManager->CheckStorageForFirstParty(firstPartyURI,
+                                          principal, changingStorage, &check);
         NS_ENSURE_SUCCESS(rv, rv);
       }
 
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -1093,6 +1093,8 @@ protected:
   nsresult RequestAnimationFrame(const nsIDocument::FrameRequestCallbackHolder& aCallback,
                                  int32_t* aHandle);
 
+  nsresult GetFirstPartyURI(nsIURI** aFirstPartyURI);
+
   // When adding new member variables, be careful not to create cycles
   // through JavaScript.  If there is any chance that a member variable
   // could own objects that are implemented in JavaScript, then those
diff --git a/dom/interfaces/storage/nsIDOMStorageManager.idl b/dom/interfaces/storage/nsIDOMStorageManager.idl
index a839fb6..6d1c5fc 100644 (file)
--- a/dom/interfaces/storage/nsIDOMStorageManager.idl
+++ b/dom/interfaces/storage/nsIDOMStorageManager.idl
@@ -7,26 +7,36 @@
 
 interface nsIDOMStorage;
 interface nsIPrincipal;
+interface nsIURI;
 
 /**
  * General purpose interface that has two implementations, for localStorage
  * resp. sessionStorage with "@mozilla.org/dom/localStorage-manager;1" resp.
  * "@mozilla.org/dom/sessionStorage-manager;1" contract IDs.
  */
-[scriptable, uuid(8096f9ea-fa61-4960-b5d7-fb30ac42c8d8)]
+[scriptable, uuid(96dd7614-fcc8-4745-9a1d-52f44dea8818)]
 interface nsIDOMStorageManager : nsISupports
 {
   /**
    * This starts async preloading of a storage cache for scope
    * defined by the principal.
+   *
+   * @param aFirstPartyURI
+   *    First party URI to bound storage to.
+   * @param aPrincipal
+   *    Principal to bound storage to.
    */
   void precacheStorage(in nsIPrincipal aPrincipal);
+  void precacheStorageForFirstParty(in nsIURI aFirstPartyURI,
+                                    in nsIPrincipal aPrincipal);
 
   /**
    * Returns instance of DOM storage object for given principal.
    * A new object is always returned and it is ensured there is
    * a storage for the scope created.
    *
+   * @param aFirstPartyURI
+   *    First party URI to bound storage to.
    * @param aPrincipal
    *    Principal to bound storage to.
    * @param aDocumentURI
@@ -37,6 +47,10 @@ interface nsIDOMStorageManager : nsISupports
   nsIDOMStorage createStorage(in nsIPrincipal aPrincipal,
                               in DOMString aDocumentURI,
                               [optional] in bool aPrivate);
+  nsIDOMStorage createStorageForFirstParty(in nsIURI aFirstPartyURI,
+                                           in nsIPrincipal aPrincipal,
+                                           in DOMString aDocumentURI,
+                                           [optional] in bool aPrivate);
   /**
    * Returns instance of DOM storage object for given principal.
    * If there is no storage managed for the scope, then null is returned and
@@ -50,6 +64,9 @@ interface nsIDOMStorageManager : nsISupports
    */
   nsIDOMStorage getStorage(in nsIPrincipal aPrincipal,
                            [optional] in bool aPrivate);
+  nsIDOMStorage getStorageForFirstParty(in nsIURI aFirstPartyURI,
+                                        in nsIPrincipal aPrincipal,
+                                        [optional] in bool aPrivate);
 
   /**
    * Clones given storage into this storage manager.
@@ -66,6 +83,8 @@ interface nsIDOMStorageManager : nsISupports
    * Returns true if the storage belongs to the given principal and is managed
    * (i.e. has been created and is cached) by this storage manager.
    *
+   * @param aFirstPartyURI
+   *    First party URI to check the storage against.
    * @param aPrincipal
    *    Principal to check the storage against.
    * @param aStorage
@@ -78,6 +97,9 @@ interface nsIDOMStorageManager : nsISupports
    */
   bool checkStorage(in nsIPrincipal aPrincipal,
                     in nsIDOMStorage aStorage);
+  bool checkStorageForFirstParty(in nsIURI aFirstPartyURI,
+                                 in nsIPrincipal aPrincipal,
+                                 in nsIDOMStorage aStorage);
 
   /**
    * @deprecated

diff --git a/dom/src/storage/DOMStorageCache.cpp b/dom/src/storage/DOMStorageCache.cpp
--- a/dom/src/storage/DOMStorageCache.cpp
+++ b/dom/src/storage/DOMStorageCache.cpp
@@ -120,6 +120,7 @@ DOMStorageCache::Release(void)
 void
 DOMStorageCache::Init(DOMStorageManager* aManager,
                       bool aPersistent,
+                      nsIURI* aFirstPartyURI,
                       nsIPrincipal* aPrincipal,
                       const nsACString& aQuotaScope)
 {
@@ -129,6 +130,7 @@ DOMStorageCache::Init(DOMStorageManager* aManager,
 
   mManager = aManager;
   mInitialized = true;
+  mFirstPartyURI = aFirstPartyURI;
   mPrincipal = aPrincipal;
   mPersistent = aPersistent;
   mQuotaScope = aQuotaScope.IsEmpty() ? mScope : aQuotaScope;

diff --git a/dom/src/storage/DOMStorageCache.h b/dom/src/storage/DOMStorageCache.h
index c5626e4..42836ac 100644 (file)
--- a/dom/src/storage/DOMStorageCache.h
+++ b/dom/src/storage/DOMStorageCache.h
@@ -6,6 +6,7 @@
 #ifndef nsDOMStorageCache_h___
 #define nsDOMStorageCache_h___
 
+#include "nsIURI.h"
 #include "nsIPrincipal.h"
 #include "nsITimer.h"
 
@@ -70,7 +71,8 @@ public:
   DOMStorageCache(const nsACString* aScope);
   virtual ~DOMStorageCache();
 
-  void Init(DOMStorageManager* aManager, bool aPersistent, nsIPrincipal* aPrincipal,
+  void Init(DOMStorageManager* aManager, bool aPersistent,
+            nsIURI* aFirstPartyURI, nsIPrincipal* aPrincipal,
             const nsACString& aQuotaScope);
 
   // Copies all data from the other storage.
@@ -95,6 +97,8 @@ public:
 
   nsTArray<nsString>* GetKeys(const DOMStorage* aStorage);
 
+  nsIURI* FirstPartyURI() const { return mFirstPartyURI; }
+
   // Whether the principal equals principal the cache was created for
   bool CheckPrincipal(nsIPrincipal* aPrincipal) const;
   nsIPrincipal* Principal() const { return mPrincipal; }
@@ -172,6 +176,9 @@ private:
   // Timer that holds this cache alive for a while after it has been preloaded.
   nsCOMPtr<nsITimer> mKeepAliveTimer;
 
+  // The first party URI associated with this cache.
+  nsCOMPtr<nsIURI> mFirstPartyURI;
+
   // Principal the cache has been initially created for, this is used only
   // for sessionStorage access checks since sessionStorage objects are strictly
   // scoped by a principal.  localStorage objects on the other hand are scoped by

diff --git a/dom/src/storage/DOMStorageManager.cpp b/dom/src/storage/DOMStorageManager.cpp
--- a/dom/src/storage/DOMStorageManager.cpp
+++ b/dom/src/storage/DOMStorageManager.cpp
@@ -15,6 +15,7 @@
 #include "nsXULAppAPI.h"
 #include "nsThreadUtils.h"
 #include "nsIObserverService.h"
+#include "mozIThirdPartyUtil.h"
 #include "mozilla/Services.h"
 #include "mozilla/Preferences.h"
 
@@ -131,7 +132,28 @@ DOMStorageManager::~DOMStorageManager()
 namespace { // anon
 
 nsresult
-CreateScopeKey(nsIPrincipal* aPrincipal,
+AppendFirstPartyToKey(nsIURI* aFirstPartyURI, nsACString& aKey)
+{
+  if (aFirstPartyURI) {
+    nsCOMPtr<mozIThirdPartyUtil> thirdPartyUtil =
+                            do_GetService(THIRDPARTYUTIL_CONTRACTID);
+    if (!thirdPartyUtil)
+      return NS_ERROR_FAILURE;
+
+    nsAutoCString firstPartyHost;
+    nsresult rv = thirdPartyUtil->GetFirstPartyHostForIsolation(aFirstPartyURI,
+                                                                firstPartyHost);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    aKey.AppendLiteral("&");
+    aKey.Append(firstPartyHost);
+  }
+
+  return NS_OK;
+}
+
+nsresult
+CreateScopeKey(nsIURI* aFirstPartyURI, nsIPrincipal* aPrincipal,
                nsACString& aKey)
 {
   nsCOMPtr<nsIURI> uri;
@@ -198,21 +220,22 @@ CreateScopeKey(nsIPrincipal* aPrincipal,
 
     if (appId == nsIScriptSecurityManager::NO_APP_ID && !isInBrowserElement) {
       aKey.Assign(key);
-      return NS_OK;
+    } else {
+      aKey.Truncate();
+      aKey.AppendInt(appId);
+      aKey.Append(NS_LITERAL_CSTRING(":") + (isInBrowserElement ?
+                  NS_LITERAL_CSTRING("t") : NS_LITERAL_CSTRING("f")) +
+                  NS_LITERAL_CSTRING(":") + key);
     }
-
-    aKey.Truncate();
-    aKey.AppendInt(appId);
-    aKey.Append(NS_LITERAL_CSTRING(":") + (isInBrowserElement ?
-                NS_LITERAL_CSTRING("t") : NS_LITERAL_CSTRING("f")) +
-                NS_LITERAL_CSTRING(":") + key);
   }
 
-  return NS_OK;
+  // Isolate scope keys to the URL bar domain by appending &firstPartyHost
+  // if available.
+  return AppendFirstPartyToKey(aFirstPartyURI, aKey);
 }
 
 nsresult
-CreateQuotaDBKey(nsIPrincipal* aPrincipal,
+CreateQuotaDBKey(nsIURI* aFirstPartyURI, nsIPrincipal* aPrincipal,
                  nsACString& aKey)
 {
   nsresult rv;
@@ -252,17 +275,18 @@ CreateQuotaDBKey(nsIPrincipal* aPrincipal,
 
     if (appId == nsIScriptSecurityManager::NO_APP_ID && !isInBrowserElement) {
       aKey.Assign(subdomainsDBKey);
-      return NS_OK;
+    } else {
+      aKey.Truncate();
+      aKey.AppendInt(appId);
+      aKey.Append(NS_LITERAL_CSTRING(":") + (isInBrowserElement ?
+                  NS_LITERAL_CSTRING("t") : NS_LITERAL_CSTRING("f")) +
+                  NS_LITERAL_CSTRING(":") + subdomainsDBKey);
     }
-
-    aKey.Truncate();
-    aKey.AppendInt(appId);
-    aKey.Append(NS_LITERAL_CSTRING(":") + (isInBrowserElement ?
-                NS_LITERAL_CSTRING("t") : NS_LITERAL_CSTRING("f")) +
-                NS_LITERAL_CSTRING(":") + subdomainsDBKey);
   }
 
-  return NS_OK;
+  // Isolate scope keys to the URL bar domain by appending &firstPartyHost
+  // if available.
+  return AppendFirstPartyToKey(aFirstPartyURI, aKey);
 }
 
 } // anon
@@ -280,24 +304,23 @@ DOMStorageManager::GetCache(const nsACString& aScope) const
 
 already_AddRefed<DOMStorageCache>
 DOMStorageManager::PutCache(const nsACString& aScope,
+                            nsIURI* aFirstPartyURI,
                             nsIPrincipal* aPrincipal)
 {
   DOMStorageCacheHashKey* entry = mCaches.PutEntry(aScope);
   nsRefPtr<DOMStorageCache> cache = entry->cache();
 
   nsAutoCString quotaScope;
-  CreateQuotaDBKey(aPrincipal, quotaScope);
+  CreateQuotaDBKey(aFirstPartyURI, aPrincipal, quotaScope);
 
+  // To avoid ever persisting session storage to disk, initialize LocalStorage
+  // like SessionStorage.
   switch (mType) {
   case SessionStorage:
+  case LocalStorage:
     // Lifetime handled by the manager, don't persist
     entry->HardRef();
-    cache->Init(nullptr, false, aPrincipal, quotaScope);
-    break;
-
-  case LocalStorage:
-    // Lifetime handled by the cache, do persist
-    cache->Init(this, true, aPrincipal, quotaScope);
+    cache->Init(nullptr, false, aFirstPartyURI, aPrincipal, quotaScope);
     break;
 
   default:
@@ -319,6 +342,7 @@ DOMStorageManager::DropCache(DOMStorageCache* aCache)
 
 nsresult
 DOMStorageManager::GetStorageInternal(bool aCreate,
+                                      nsIURI* aFirstPartyURI,
                                       nsIPrincipal* aPrincipal,
                                       const nsAString& aDocumentURI,
                                       bool aPrivate,
@@ -327,7 +351,7 @@ DOMStorageManager::GetStorageInternal(bool aCreate,
   nsresult rv;
 
   nsAutoCString scope;
-  rv = CreateScopeKey(aPrincipal, scope);
+  rv = CreateScopeKey(aFirstPartyURI, aPrincipal, scope);
   if (NS_FAILED(rv)) {
     return NS_ERROR_NOT_AVAILABLE;
   }
@@ -358,7 +382,7 @@ DOMStorageManager::GetStorageInternal(bool aCreate,
 
     // There is always a single instance of a cache per scope
     // in a single instance of a DOM storage manager.
-    cache = PutCache(scope, aPrincipal);
+    cache = PutCache(scope, aFirstPartyURI, aPrincipal);
   } else if (mType == SessionStorage) {
     if (!cache->CheckPrincipal(aPrincipal)) {
       return NS_ERROR_DOM_SECURITY_ERR;
@@ -376,7 +400,16 @@ DOMStorageManager::GetStorageInternal(bool aCreate,
 NS_IMETHODIMP
 DOMStorageManager::PrecacheStorage(nsIPrincipal* aPrincipal)
 {
-  return GetStorageInternal(true, aPrincipal, EmptyString(), false, nullptr);
+  return GetStorageInternal(true, nullptr, aPrincipal, EmptyString(),
+                            false, nullptr);
+}
+
+NS_IMETHODIMP
+DOMStorageManager::PrecacheStorageForFirstParty(nsIURI* aFirstPartyURI,
+                                                nsIPrincipal* aPrincipal)
+{
+  return GetStorageInternal(true, aFirstPartyURI, aPrincipal, EmptyString(),
+                            false, nullptr);
 }
 
 NS_IMETHODIMP
@@ -385,7 +418,19 @@ DOMStorageManager::CreateStorage(nsIPrincipal* aPrincipal,
                                  bool aPrivate,
                                  nsIDOMStorage** aRetval)
 {
-  return GetStorageInternal(true, aPrincipal, aDocumentURI, aPrivate, aRetval);
+  return GetStorageInternal(true, nullptr, aPrincipal, aDocumentURI,
+                            aPrivate, aRetval);
+}
+
+NS_IMETHODIMP
+DOMStorageManager::CreateStorageForFirstParty(nsIURI* aFirstPartyURI,
+                                              nsIPrincipal* aPrincipal,
+                                              const nsAString& aDocumentURI,
+                                              bool aPrivate,
+                                              nsIDOMStorage** aRetval)
+{
+  return GetStorageInternal(true, aFirstPartyURI, aPrincipal, aDocumentURI,
+                            aPrivate, aRetval);
 }
 
 NS_IMETHODIMP
@@ -393,7 +438,18 @@ DOMStorageManager::GetStorage(nsIPrincipal* aPrincipal,
                               bool aPrivate,
                               nsIDOMStorage** aRetval)
 {
-  return GetStorageInternal(false, aPrincipal, EmptyString(), aPrivate, aRetval);
+  return GetStorageInternal(false, nullptr, aPrincipal, EmptyString(),
+                            aPrivate, aRetval);
+}
+
+NS_IMETHODIMP
+DOMStorageManager::GetStorageForFirstParty(nsIURI* aFirstPartyURI,
+                                           nsIPrincipal* aPrincipal,
+                                           bool aPrivate,
+                                           nsIDOMStorage** aRetval)
+{
+  return GetStorageInternal(false, aFirstPartyURI, aPrincipal,
+                            EmptyString(), aPrivate, aRetval);
 }
 
 NS_IMETHODIMP
@@ -420,6 +476,7 @@ DOMStorageManager::CloneStorage(nsIDOMStorage* aStorage)
   // Since this manager is sessionStorage manager, PutCache hard references
   // the cache in our hashtable.
   nsRefPtr<DOMStorageCache> newCache = PutCache(origCache->Scope(),
+                                                origCache->FirstPartyURI(),
                                                 origCache->Principal());
 
   newCache->CloneFrom(origCache);
@@ -431,6 +488,15 @@ DOMStorageManager::CheckStorage(nsIPrincipal* aPrincipal,
                                 nsIDOMStorage* aStorage,
                                 bool* aRetval)
 {
+  return CheckStorageForFirstParty(nullptr, aPrincipal, aStorage, aRetval);
+}
+
+NS_IMETHODIMP
+DOMStorageManager::CheckStorageForFirstParty(nsIURI* aFirstPartyURI,
+                                             nsIPrincipal* aPrincipal,
+                                             nsIDOMStorage* aStorage,
+                                             bool* aRetval)
+{
   nsCOMPtr<nsPIDOMStorage> pstorage = do_QueryInterface(aStorage);
   if (!pstorage) {
     return NS_ERROR_UNEXPECTED;
@@ -443,7 +509,7 @@ DOMStorageManager::CheckStorage(nsIPrincipal* aPrincipal,
   }
 
   nsAutoCString scope;
-  nsresult rv = CreateScopeKey(aPrincipal, scope);
+  nsresult rv = CreateScopeKey(aFirstPartyURI, aPrincipal, scope);
   NS_ENSURE_SUCCESS(rv, rv);
 
   DOMStorageCache* cache = GetCache(scope);

diff --git a/dom/src/storage/DOMStorageManager.h b/dom/src/storage/DOMStorageManager.h
--- a/dom/src/storage/DOMStorageManager.h
+++ b/dom/src/storage/DOMStorageManager.h
@@ -74,10 +74,12 @@ private:
   // Ensures cache for a scope, when it doesn't exist it is created and initalized,
   // this also starts preload of persistent data.
   already_AddRefed<DOMStorageCache> PutCache(const nsACString& aScope,
+                                             nsIURI* aFirstPartyURI,
                                              nsIPrincipal* aPrincipal);
 
   // Helper for creation of DOM storage objects
   nsresult GetStorageInternal(bool aCreate,
+                              nsIURI* aFirstPartyURI,
                               nsIPrincipal* aPrincipal,
                               const nsAString& aDocumentURI,
                               bool aPrivate,

diff --git a/embedding/components/windowwatcher/src/nsWindowWatcher.cpp b/embedding/components/windowwatcher/src/nsWindowWatcher.cpp
--- a/embedding/components/windowwatcher/src/nsWindowWatcher.cpp
+++ b/embedding/components/windowwatcher/src/nsWindowWatcher.cpp
@@ -947,7 +947,8 @@ nsWindowWatcher::OpenWindowInternal(nsIDOMWindow *aParent,
 
     if (parentStorageManager && newStorageManager) {
       nsCOMPtr<nsIDOMStorage> storage;
-      parentStorageManager->GetStorage(subjectPrincipal, isPrivateBrowsingWindow, getter_AddRefs(storage));
+      parentStorageManager->GetStorageForFirstParty(uriToLoad, subjectPrincipal,
+                             isPrivateBrowsingWindow, getter_AddRefs(storage));
       if (storage)
         newStorageManager->CloneStorage(storage);
     }
